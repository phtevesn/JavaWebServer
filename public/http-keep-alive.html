<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTTP Keep-Alive Deep Dive</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 { color: #667eea; border-bottom: 3px solid #667eea; padding-bottom: 10px; }
        h2 { color: #764ba2; margin-top: 30px; }
        h3 { color: #667eea; margin-top: 20px; }
        .code-block {
            background: #f8f9fa;
            border-left: 4px solid #667eea;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
            white-space: pre;
        }
        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        .comparison-box {
            border: 2px solid #ddd;
            padding: 15px;
            border-radius: 5px;
        }
        .comparison-box.bad { border-color: #dc3545; }
        .comparison-box.good { border-color: #28a745; }
        .comparison-box h4 { margin-top: 0; }
        .bad h4 { color: #dc3545; }
        .good h4 { color: #28a745; }
        .note {
            background: #d1ecf1;
            border-left: 4px solid #0c5460;
            padding: 15px;
            margin: 15px 0;
        }
        .warning {
            background: #fff3cd;
            border-left: 4px solid #856404;
            padding: 15px;
            margin: 15px 0;
        }
        .back-link {
            display: inline-block;
            margin-bottom: 20px;
            color: #667eea;
            text-decoration: none;
        }
        .back-link:hover { text-decoration: underline; }
        .diagram {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
            text-align: center;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">‚Üê Back to Home</a>

        <h1>HTTP Keep-Alive Deep Dive</h1>

        <p>HTTP Keep-Alive (also called persistent connections) allows multiple HTTP requests/responses to be sent over a single TCP connection. This is one of the most important performance optimizations in modern web servers.</p>

        <h2>The Problem: Connection-Per-Request</h2>

        <p>Without keep-alive, every HTTP request requires:</p>
        <ol>
            <li>TCP 3-way handshake (1.5 round trips)</li>
            <li>HTTP request/response exchange</li>
            <li>TCP connection teardown (4-way handshake)</li>
        </ol>

        <div class="diagram">
Client ‚Üí Server: SYN
Server ‚Üí Client: SYN-ACK
Client ‚Üí Server: ACK (connection established)
Client ‚Üí Server: HTTP GET
Server ‚Üí Client: HTTP Response
Client ‚Üí Server: FIN
Server ‚Üí Client: ACK
Server ‚Üí Client: FIN
Client ‚Üí Server: ACK (connection closed)
        </div>

        <p><strong>For 100 requests, this means 100 TCP handshakes!</strong></p>

        <h2>The Solution: Keep-Alive</h2>

        <p>With keep-alive, the TCP connection stays open after the response is sent, allowing the client to send additional requests:</p>

        <div class="diagram">
Client ‚Üí Server: SYN
Server ‚Üí Client: SYN-ACK
Client ‚Üí Server: ACK (connection established)
Client ‚Üí Server: HTTP GET #1
Server ‚Üí Client: HTTP Response #1
Client ‚Üí Server: HTTP GET #2
Server ‚Üí Client: HTTP Response #2
Client ‚Üí Server: HTTP GET #3
Server ‚Üí Client: HTTP Response #3
... (many more requests) ...
Client ‚Üí Server: FIN (finally close)
        </div>

        <p><strong>For 100 requests, this means 1 TCP handshake!</strong></p>

        <h2>Performance Comparison</h2>

        <div class="comparison">
            <div class="comparison-box bad">
                <h4>‚ùå Without Keep-Alive</h4>
                <ul>
                    <li>100 connections for 100 requests</li>
                    <li>100 TCP handshakes (150ms+ overhead)</li>
                    <li>Uses 100 ephemeral ports</li>
                    <li>Higher latency per request</li>
                    <li>More CPU/memory on server</li>
                </ul>
            </div>
            <div class="comparison-box good">
                <h4>‚úÖ With Keep-Alive</h4>
                <ul>
                    <li>1 connection for 100 requests</li>
                    <li>1 TCP handshake (one-time cost)</li>
                    <li>Uses 1 ephemeral port</li>
                    <li>Lower latency per request</li>
                    <li>Less CPU/memory on server</li>
                </ul>
            </div>
        </div>

        <h2>The Connection Header</h2>

        <p>In HTTP/1.1, keep-alive is the <strong>default</strong>. The <code>Connection</code> header controls this behavior:</p>

        <h3>Client Request Headers</h3>
        <div class="code-block"># Client wants to keep connection alive
Connection: keep-alive

# Client wants to close after this request
Connection: close

# HTTP/1.1 default (no header = keep-alive)
(no Connection header)</div>

        <h3>Server Response Headers</h3>
        <div class="code-block"># Server agrees to keep-alive
Connection: keep-alive

# Server will close after this response
Connection: close</div>

        <div class="note">
            <strong>üí° Key Point:</strong> Either side can request closure. If the client sends <code>Connection: close</code>, the server should honor it even if keep-alive is enabled.
        </div>

        <h2>How Timeout Works</h2>

        <p>The server can't keep connections open forever. After sending a response, the server waits for the next request with a timeout:</p>

        <div class="code-block">socket.setSoTimeout(5000); // 5 second timeout

while (true) {
    try {
        // Wait for next request (with timeout)
        String requestLine = in.readLine();

        if (requestLine == null) {
            // Client closed connection
            break;
        }

        // Process request...
        // Send response...

    } catch (SocketTimeoutException e) {
        // No request within timeout period
        System.out.println("Keep-alive timeout, closing connection");
        break;
    }
}</div>

        <div class="warning">
            <strong>‚ö†Ô∏è Important:</strong> The timeout applies to <strong>all socket reads</strong>, including reading the request and response data. Make sure your timeout is long enough to handle your largest expected payload transfer!
        </div>

        <h2>Common Timeout Values</h2>

        <table style="width: 100%; border-collapse: collapse; margin: 15px 0;">
            <tr style="background: #667eea; color: white;">
                <th style="border: 1px solid #ddd; padding: 12px;">Server</th>
                <th style="border: 1px solid #ddd; padding: 12px;">Default Keep-Alive Timeout</th>
            </tr>
            <tr>
                <td style="border: 1px solid #ddd; padding: 12px;">Apache</td>
                <td style="border: 1px solid #ddd; padding: 12px;">5 seconds</td>
            </tr>
            <tr style="background: #f8f9fa;">
                <td style="border: 1px solid #ddd; padding: 12px;">Nginx</td>
                <td style="border: 1px solid #ddd; padding: 12px;">75 seconds</td>
            </tr>
            <tr>
                <td style="border: 1px solid #ddd; padding: 12px;">Our Server</td>
                <td style="border: 1px solid #ddd; padding: 12px;">5 seconds (configurable with -k)</td>
            </tr>
        </table>

        <h2>Server Implementation</h2>

        <p>Here's how our server implements keep-alive:</p>

        <div class="code-block">// Enable keep-alive with timeout
if (keepAlive) {
    socket.setSoTimeout(keepAliveTimeout * 1000);
}

// Loop to handle multiple requests
while (true) {
    // Read request (might timeout here)
    String requestLine = in.readLine();

    if (requestLine == null || requestLine.isEmpty()) {
        break; // Client closed
    }

    // Parse headers
    Map&lt;String, String&gt; headers = readHeaders(in);

    // Check if client wants to close
    String connHeader = headers.get("connection");
    boolean clientWantsClose = "close".equalsIgnoreCase(connHeader);
    boolean shouldKeepAlive = keepAlive && !clientWantsClose;

    // Process request...
    handleRequest(out, path, shouldKeepAlive);

    // Send response with appropriate Connection header
    writer.print("Connection: " +
                 (shouldKeepAlive ? "keep-alive" : "close") + "\r\n");

    // Exit loop if not keeping alive
    if (!shouldKeepAlive) {
        break;
    }
}</div>

        <h2>Testing Keep-Alive</h2>

        <h3>With curl</h3>
        <div class="code-block"># Test keep-alive (curl reuses connection in HTTP/1.1)
curl http://localhost:8080/echo/100 \
     http://localhost:8080/echo/200

# Force connection close
curl -H "Connection: close" http://localhost:8080/echo/100</div>

        <h3>With the Load Test Client</h3>
        <div class="code-block"># Server with keep-alive enabled
java lts.java -k 30 8080

# Client: 10 connections, 100 requests each
# Without keep-alive on server: would need 1000 connections
# With keep-alive: only needs 10 connections
java ltc.java -c 10 -r 100</div>

        <h2>Port Exhaustion Example</h2>

        <p>Without keep-alive, you can run out of ports:</p>

        <div class="code-block"># Server without keep-alive
java lts.java 8080

# Client trying 100,000 requests
java ltc.java -c 100000 -r 1

Result: "Cannot assign requested address" after ~15,000-30,000 requests
Reason: Ephemeral port exhaustion (ports stuck in TIME_WAIT)</div>

        <p>With keep-alive:</p>

        <div class="code-block"># Server WITH keep-alive
java lts.java -k 30 8080

# Client: same 100,000 requests but reusing connections
java ltc.java -c 1000 -r 100

Result: All 100,000 requests succeed!
Reason: Only 1,000 ports needed (10,000x reduction)</div>

        <div class="note">
            <strong>üìö Further Reading:</strong>
            <ul style="margin: 10px 0 0 20px;">
                <li><a href="tcp-lifecycle.html">TCP Connection Lifecycle</a> - Understanding TIME_WAIT</li>
                <li><a href="keep-alive-performance.html">Keep-Alive Performance</a> - Detailed benchmarks</li>
                <li><a href="socket-timeouts.html">Socket Timeouts</a> - How timeouts work in Java</li>
            </ul>
        </div>

        <p style="margin-top: 40px;"><a href="index.html" class="back-link">‚Üê Back to Home</a></p>
    </div>
</body>
</html>
